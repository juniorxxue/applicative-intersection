%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% METAVARIABLES

metavar var, x , y ::= {{ repr-locally-nameless }}

metavar i, l ::= {{ coq nat }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% GRAMMAR (LNgen portion)

grammar

typ, A {{ tex A }}, B {{ tex B }}, C {{ tex C }}, D {{ tex D }}, E {{ tex E }}, O {{ tex O }}, char {{ tex \mathsf{Char} }}, bool {{ tex \mathsf{Bool} }} :: 't_' ::= {{ com types }}
  | Int            ::  :: int     {{ com int }}
  | Top            ::  :: top     {{ com top }}
  | A -> B         ::  :: arrow   {{ com function types }}
  | A & B          ::  :: and     {{ com intersection }}
  | { l : A }      ::  :: rcd     {{ com record }}
  | ( A )          :: S:: paren   {{ coq [[A]] }}


exp, e {{ tex e }}, v {{ tex v }}, p {{ tex p }}, u {{ tex u }}, one_e {{ tex 1 }}, two_e {{ tex 2 }}, v_f {{ tex v_f }} :: 'e_'     ::=       {{ com expressions }}
  | x              ::  :: var     {{ com variables }}
  | T              ::  :: top     {{ com top }}
  | i              ::  :: lit     {{ com lit }}
  | \ x : A . e : B
                   ::  :: abs     (+ bind x in e +)
                                  {{ com abstractions }}
                            {{ tex [[\]][[x]].\,[[e]][[:]][[A]][[->]][[B]] }}
  | e1 e2          ::  :: app     {{ com applications }}
  | e1 ,, e2       ::  :: merge   {{ com merge }}
  | e : A          ::  :: anno    {{ com annotation }}
  | { l = e }      ::  :: rcd     {{ com record }}
  | e . l          ::  :: proj    {{ com projection }}
  | e1 [ x ~> e2 ] :: M:: subst   {{ coq (open_exp_wrt_exp [[x e1]][[e2]]) }}
  | [ e <-- x ]    :: M:: close   {{ coq (close_exp_wrt_exp [[x]] [[e]]) }}
  | ( e )          :: S:: paren   {{ coq ([[e]]) }}



substitutions
  single exp x   :: subst


freevars
  exp x      :: fv


parsing
  t_arrow <= t_and
  t_arrow right t_arrow

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% GRAMMAR  (non LNgen portion)

grammar

ctx, G {{ tex \Gamma }} :: 'ctx_' ::= {{ com typing context }} {{ coq list ( atom * typ ) }}
  | []           ::  :: empty      {{ coq nil }}
                                   {{ tex \cdot }}
                                   {{ com empty context }}
  | G , x : A    ::  :: cons       {{ coq (cons ([[x]],[[A]]) [[G]]) }}
                                   {{ com assumption }}


arg, S {{ tex S }} :: 'arg_' ::= {{ com argument }} {{ coq option typ }}
  | []           ::  :: none      {{ coq None }}
                                   {{ tex \cdot }}
                                   {{ com empty context }}
  | A            ::  :: typ        {{ coq Some [[A]] }}
                                   {{ com assumption }}
  | l            ::  :: lbl        {{ com label }}                                   

dirflag :: '' ::= {{ com checking direction }}
  | =>             ::   :: Inf
  | <=             ::   :: Chk


vl :: 'vl_' ::=  {{ com value or projection label }}
  | v            ::  :: exp
  | { l }        ::  :: la


terminals :: 'terminals_' ::=
  | \            ::  :: lambda     {{ tex \lambda }}
  | ~>           ::  :: subst      {{ tex \mapsto }}
  | ->           ::  :: arrow      {{ tex \rightarrow }}
  | -->          ::  :: longarrow  {{ tex \rightrightarrows }}
  | ~->          ::  :: sarrow     {{ tex \rightsquigarrow }}
  | |->          ::  :: red        {{ tex \longmapsto }}
  | <=           ::  :: check      {{ tex \Leftarrow }}
  | =>           ::  :: infer      {{ tex \Rightarrow }}
  | is           ::  :: typeof     {{ tex :}}
  | |-           ::  :: turnstile  {{ tex \vdash }}
  | |=           ::  :: dash2      {{ tex \models }}
  | T            ::  :: t          {{ tex \top }}
  | Top          ::  :: top        {{ tex \mathsf{Top}  }}
  | Int          ::  :: int        {{ tex \mathsf{Int}  }}
  | ,,           ::  :: Merge      {{ tex \,,,\, }}
  | &            ::  :: And        {{ tex \, \& \, }}
  | :            ::  :: Typ        {{ tex : }}
  | in           ::  :: in         {{ tex \in }}
  | ;            ::  :: ctxAnd     {{ tex ; }}
  | ,            ::  :: break      {{ tex , }}
  | split        ::  :: split      {{ tex \mathsf{Split} }}
  | ordinary     ::  :: ordinary   {{ tex \mathsf{Ordinary} }}
  | topLike      ::  :: topLike    {{ tex \mathsf{TOPLIKE} }}
  | <*>          ::  :: disjointSpec    {{ tex ** }}
  | *            ::  :: disjoint        {{ tex * }}
  | ~            ::  :: consistencySpec {{ tex \approx }}
  | ~~           ::  :: consistent {{ tex \approx\approx }}
  | <            ::  :: val2exprl  {{ tex \langle}}
  | >            ::  :: val2exprr  {{ tex \rangle}}
  | topl         ::  :: topl       {{ tex \rceil }}
  | topr         ::  :: topr       {{ tex \lceil }}
  | fix          ::  :: fixpoint   {{ tex \mathsf{fix} }}

formula :: 'formula_' ::=
  | judgement                ::   :: judgement
  | not formula              :: M :: not
    {{ tex \neg [[formula]] }}
    {{ coq not ([[formula]]) }}
  | formula1 or formula2              :: M :: or
    {{ tex [[formula1]]~\lor~[[formula2]] }}
    {{ coq ([[formula1]] \/ [[formula2]]) }}
  | ( formula )              :: M :: brackets
    {{ tex ([[formula]]\!) }}
    {{ coq [[formula]] }}
  | uniq G                   ::   :: uniqG
    {{ coq uniq [[G]] }}
    {{ tex }}
  | x : A in G               ::   :: inG
    {{ coq binds [[x]][[A]][[G]] }}
  | x notin fv e             ::   :: fresh
    {{ coq [[x]] \notin fv[[e]] }}
  | x notin dom G            ::   :: notInGx
    {{ coq ~ AtomSetImpl.In [[x]] (dom [[G]]) }}
    {{ tex [[x]] \notin [[G]] }}
  | l1 <> l2                 ::   :: label
    {{ coq [[l1]] <> [[l2]] }}
    {{ tex [[l1]] \neq [[l2]] }}
  | A <*> B                  :: M :: disjointSpec
    {{ coq disjointSpec[[A]][[B]] }}
  | v1 ~ v2                  :: M :: consistencySpec
    {{ coq consistencySpec[[v1]][[v2]] }}
    {{ tex \mathsf{consistencySpec}~[[v1]]~[[v2]] }}
  | e1 --> i e2               :: M :: multistep
    {{ coq (star exp step)[[i]][[e1]][[e2]] }}
    {{ tex [[e1]]~[[-->]][[i]]~[[e2]] }}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
defns
Values :: '' ::=

defn
value e ::  :: value :: value_ {{ com Values }} {{ tex }}
by



---------------------- :: lit
value i


--------------------------------- :: anno
value \x : A . e : B


value v
----------------------- :: rcd
value {l=v}


value v1
value v2
----------------------- :: merge
value v1 ,, v2


defns
Pvalues :: '' ::=

defn
pvalue p :: :: pvalue :: pvalue_ {{com PValues}} {{ tex pvalue~~[[p]]}}
by


---------------------- :: lit
pvalue i


--------------------------------- :: arrow
pvalue \x : A . e : B


defns
TopLikeType :: '' ::=

defn
topLike A :: :: topLike :: TL_
{{ com Top-like Types }}
{{ tex [[topl]][[A]][[topr]] }}
by


---------------- :: top
topLike Top

topLike A
topLike B
---------------- :: and
topLike A & B

topLike B
---------------- :: arr
topLike A -> B

topLike B
---------------- :: rcd
topLike {l:B}

defns
SplitType :: '' ::=

defn
split A B C :: :: spl :: Sp_
{{ com Splitable Types }}
{{ tex [[B]] \hookleftarrow [[A]] \hookrightarrow [[C]] }}
by


----------------:: and
split (A&B) (A) (B)


split B B1 B2
----------------------------- :: arrow
split (A->B) (A->B1) (A->B2)


split B B1 B2
-------------------------- :: rcd
split {l:B} {l:B1} {l:B2}


defns
OrdinaryType :: '' ::=

defn
ordinary A :: :: ord :: O_
{{ com Ordinary Types }}
{{ tex [[A]]~[[ordinary]] }}
by


---------------- :: top
ordinary Top


---------------- :: int
ordinary Int


ordinary B
---------------- :: arrow
ordinary A->B


ordinary B
---------------- :: rcd
ordinary {l:B}

defns
Disjoint :: '' ::=

defn A * B :: :: disjoint    :: 'D_'
{{ com Type Disjointness (Algorithmic) }}
by


--------------- :: topL
Top * A


------------------ :: topR
A * Top


A1 * B
A2 * B
--------------- :: andL
A1 & A2 * B


A * B1
A * B2
--------------- :: andR
A * B1 & B2


---------------------- :: IntArr
Int * A1 -> A2


---------------------- :: ArrInt
A1 -> A2 * Int


A2 * B2
---------------------- :: ArrArr
A1 -> A2 * B1 -> B2

A * B
------------------------ :: rcdEq
{ l : A } * { l : B }


l1 <> l2
------------------------- :: rcdNeq
{ l1 : A } * { l2 : B }


---------------------- :: IntRcd
Int * { l : A }


---------------------- :: RcdInt
{ l : A } * Int


---------------------- :: ArrRcd
A1 -> A2 * { l : A }


---------------------- :: RcdArr
{ l : A } * A1 -> A2


defns
OriginalBCDDeclarativeSubtyping :: '' ::=

defn
A < B  :: :: original_bcd_sub :: OS_
{{ com Original BCD Declarative Subtyping (\textless)}}
{{ tex [[A]] \leq [[B]] }}
by


---------------------- :: refl
A < A


A < B
B < C
--------------- :: trans
A < C


--------------- :: top
A < Top


--------------------------- :: topArr
Top < Top -> Top


------------------------------- :: topRcd
Top < { l : Top }


B < A
C < D
------------------------ :: arr
A -> C < B -> D


A < B
A < C
--------------- :: and
A < B & C


------------------------- :: andl
A & B < A


----------------- :: andr
A & B < B


----------------------------------------------------- :: distArr
(A -> B) & (A -> C) < A -> B & C


A < B
-------------------------------------------- :: rcd
{ l : A } < { l : B }


--------------------------------------------------- :: distRcd
{ l : A } & { l : B } < { l : A & B }



defns
AlgorithmicSubtyping :: '' ::=

defn
A <: B  :: :: algo_sub :: S_
{{ com Algorithmic (Modular) Subtyping }}
{{ tex [[A]] [[<:]] [[B]] }}
by


---------------------- :: int
Int <: Int


ordinary B
topLike B
--------------- :: top
A <: B

ordinary D
B <: A
C <: D
------------------------ :: arr
A -> C <: B -> D


ordinary D
C <: D 
------------------------ :: rcd
{l:C} <: {l:D}


ordinary C
A <: C
------------------------- :: andl
A & B <: C


ordinary C
B <: C
----------------- :: andr
A & B <: C



split D B C
A <: B
A <: C
--------------- :: and
A <: D



defns
ModularSubtyping :: '' ::=

defn
A <:: B  :: :: msub :: MS_
{{ com Modular Subtyping (without ordinary-conditions)}}
{{ tex [[A]] [[<:]]_m [[B]] }}
by


---------------------- :: int
Int <:: Int


topLike B
--------------- :: top
A <:: B


A <:: C
------------------------- :: andl
A & B <:: C


B <:: C
----------------- :: andr
A & B <:: C


B <:: A
C <:: D
------------------------ :: arr
A -> C <:: B -> D


C <:: D
------------------------ :: rcd
{l:C} <:: {l:D}


split D B C
A <:: B
A <:: C
--------------- :: and
A <:: D



defns
SubSubtyping :: '' ::=

defn
A <<: B  :: :: IsoSub :: isosub_
{{ com Isomorphic Subtyping }}
{{ tex [[A]] \ll [[B]] }}
by


--------------- :: refl
A <<: A


split B B1 B2
A1 <<: B1
A2 <<: B2
------------------------ :: And
A1 & A2 <<: B


A <<: B 
------------------------ :: rcd
{l:A} <<: {l:B}


defns
AppsubBinary :: '' ::=

defn
S |- A :: :: appSubBin :: ASB_
{{ com Applicative Subtyping (Binary) }}
{{ tex [[S]] [[|-]] [[A]]}}
by

------------------- :: refl
[] |- A


C <: A
------------------- :: arrow
C |- A -> B


------------------- :: lbl
l |- {l:A} 


S |- A
------------------- :: andL
S |- A&B


S |- B
------------------- :: andR
S |- A&B


defns
Appsub :: '' ::=

defn
S |- A <: B  :: :: appSub :: AS_
{{ com Applicative Subtyping}}
{{ tex [[S]] [[|-]] [[A]] [[<:]] [[B]]}}
by


------------------- :: refl
[] |- A <: A


C <: A
------------------- :: arrow
C |- A -> B <: B


------------------- :: lbl
l |- {l:A} <: A


S |- A <: D
not S |- B
------------------- :: andL
S |- A&B <: D


S |- B <: D
not S |- A
------------------- :: andR
S |- A&B <: D


S |- A <: D1
S |- B <: D2
--------------------- :: andBoth
S |- A&B <: D1&D2


defns
TypedReduction :: '' ::=

defn
v -> A  v'  :: :: TypedReduce :: TReduce_
{{ tex [[v]]\,[[|->]]_{[[A]]}\,[[v']] }}
{{ com Typed Reduction }}
by

A <: Int
------------------------ :: refl
i  : A -> Int  i : Int


ordinary A
topLike A
------------------------------------------- :: top
v  ->A (one_e : A)


ordinary D
not topLike D
E <: (C -> D)
----------------------------------------------------------- :: arrow
(\ x : A . e : B):E  ->(C -> D)  (\ x : A . e : D): C -> D

ordinary A
not topLike A
v ->A v'
-------------------------- :: rcd
{l=v} ->{l:A} {l=v'}


ordinary A
v1 ->A  v1'
--------------------------------- :: mergevl
v1,,v2 ->A  v1'


ordinary A
v2 ->A  v2'
--------------------------------- :: mergevr
v1,,v2 ->A  v2'


split A B C
v ->B v1
v ->C v2
--------------------------------------- :: and
v ->A v1,,v2


defns
PrincipalType :: '' ::=

defn
pType u A ::  :: pType :: PT_ {{ com Principal Type of pre-values }} {{ tex \mathsf{pType}~[[u]]~[[A]] }}
by


---------------------- :: int
pType i Int


---------------------- :: lam
pType (\x:A.e:B) (A->B)


---------------------- :: anno
pType (e:A) A


pType u A
---------------------- :: rcd
pType {l=u} {l:A} 


pType u1 A
pType u2 B
---------------------- :: merge
pType (u1,,u2) (A&B)


defns
ArgumentalType :: '' ::=

defn
aType vl arg ::  :: aType :: AT_ {{ com }} {{ tex \mathsf{aType}~[[vl]]~[[S]] }}
by


---------------------- :: anno
aType (e:A) A


aType e A
---------------------- :: rcd
aType {l=e} {l:A} 


aType e1 A
aType e2 B
---------------------- :: merge
aType (e1,,e2) (A&B)


---------------------- :: label
aType l l


defns
ParallelApplication :: '' ::=

defn
v1 ; vl --> e :: :: papp :: Papp_
{{ tex ([[v1]]~[[vl]])~[[-->]]~[[e]] }}
{{ com Parallel Application }}
by



topLike B
----------------------------------- :: intToplike
(i : A -> B) ; v --> one_e : B


topLike A
----------------------------------- :: intToplikeR
(i : {l : A}) ; v --> one_e : A


topLike D
--------------------------------------- :: arrToplike
(\x:A.e:B) : C -> D ; v --> one_e : D


topLike C
--------------------------------------- :: arrToplikeR
(\x:A.e:B) : {l : C}; v --> one_e : C



---------------------------------------- :: proj
{l=v} ; l --> v


v ->A v'
not topLike D
--------------------------------------------------- :: abs
(\x:A.e:B) : C -> D ; v --> ( e [ x ~> v' ] ) : D



pType v1 A1
pType v2 A2
aType vl S
S |- A1
not S |- A2
v1 ; vl --> e
------------------------------- :: mergeL
v1,,v2 ; vl --> e


pType v1 A1
pType v2 A2
aType vl S
not S |- A1
S |- A2
v2 ; vl --> e
------------------------------- :: mergeR
v1,,v2 ; vl --> e


pType v1 A1
pType v2 A2
aType vl S
S |- A1
S |- A2
v1 ; vl --> e1
v2 ; vl --> e2
------------------------------- :: mergeParallel
v1,,v2 ; vl --> e1,,e2



defns
Reduction :: '' ::=

defn
e -->  e'  :: :: step :: Step_
{{ tex [[e]]~[[|->]]~[[e']] }}
{{ com Small-Step Semantics }}
by

---------------------- :: intAnno
i --> i:Int


----------------------------------- :: arrowAnno
(\x:A.e:B) --> (\x:A.e:B) : A -> B


split A A1 A2
--------------------------------------- :: pvalueSplit
p:A --> p:A1 ,, p:A2


value v1
value v2
v1 ; v2 --> e
----------------------  :: papp
v1 v2 --> e


value v
v ; l --> v'
-------------------------------------- :: pproj
v.l --> v'


value v
v  ->A  v'
------------------------------------------ :: annov
v : A  -->   v'


e1  -->   e1'
------------------------------------- :: appl
e1 e2  -->  e1' e2


value v1
e2  -->   e2'
------------------------------------- :: appr
v1 e2  -->  v1 e2'


e1  -->  e1'
e2  -->  e2'
------------------------------------------ :: mergeBCD
e1 ,, e2  -->   e1' ,, e2'


value v2
e1  -->  e1'
------------------------------------------ :: mergel
e1 ,, v2  -->   e1' ,, v2


value v1
e2  -->  e2'
------------------------------------------ :: merger
v1 ,, e2  -->   v1 ,, e2'


not pvalue e
e  -->  e'
------------------------------------------ :: anno
e : A  -->   e' : A


e --> e'
-------------------------------------- :: rcd
{l=e} --> {l=e'}


e --> e'
-------------------------------------- :: proj
e.l --> e'.l

defns
Consistent :: '' ::=

defn u1 ~~ u2 :: :: consistent    :: 'C_'
{{ com Consistency }}
by



----------------------------------- :: absAnno
(\x:A.e:B1):C ~~ (\x:A.e:B2):D


-------------------------- :: anno
e:A ~~ e:B


u1 ~~ u2
-------------------------- :: rcd
{l=u1} ~~ {l=u2}


pType u1 A
pType u2 B
A * B
-------------------------- :: disjoint
u1 ~~ u2


u1 ~~ u
u2 ~~ u
------------------------- :: mergel
u1,,u2 ~~ u


u ~~ u1
u ~~ u2
------------------------- :: merger
u ~~ u1,,u2



defns
Typing :: '' ::=

defn
G |- e dirflag A ::   :: Typing :: 'Typ_'
{{ com Bidirectional Typing }}
by


uniq G
----------------- :: lit
G |- i => Int


uniq G
x : A in G
-------------------------- :: var
G |- x => A


G , x : A |- e <= B
------------------------------------------- :: abs
G |- \x : A . e : B => A->B


G |- e => A
----------------------- :: rcd
G |- {l=e} => {l:A}


G |- e1 => A
G |- e2 => B
B |- A <: C
----------------------- :: app
G |- e1 e2 => C


G |- e => A
l |- A <: B
----------------------- :: proj
G |- e.l => B


G |- e1 => A
G |- e2 => B
A * B
------------------------------ :: merge
G |- e1 ,, e2 => A&B


G |- e <= A
--------------------- :: anno
G |- (e:A) => A


G |- e => A
A <: B
--------------------- :: sub
G |- e <= B

uniq G
[] |- u1 => A
[] |- u2 => B
u1 ~~ u2
------------------------------ :: mergev
G |- u1 ,, u2 => A&B